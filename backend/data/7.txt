Log in Sign up Cryptography Stack Exchange is a question and answer site for software developers, mathematicians and others interested in cryptography. It only takes a minute to sign up. Sign up to join this community Anybody can ask a question Anybody can answer The best answers are voted up and rise to the top Home PUBLIC Questions Tags Users Companies Unanswered TEAMS Stack Overflow for Teams â€“ Start collaborating and sharing organizational knowledge. Create a free Team Why Teams? Can you explain Bleichenbacher's CCA attack on PKCS#1 v1.5? Ask Question Asked 9 years, 10 months ago Modified 8 years, 3 months ago Viewed 59k times 77 I've studied that the Bleichenbacher's CCA attack on PKCS#1 v1.5. is a base to many versions of attacks in the area. I'm trying to understand that attack, but every explanation I saw starts with the technical details, without giving some overview, so it's hard to follow... Can you explain it in a simple words before giving the little details? encryptionrsapublic-keychosen-ciphertext-attack Share Improve this question Follow asked Jan 2, 2014 at 14:24 Bush 2,1302 2 gold badges 18 18 silver badges 26 26 bronze badges Add a comment 1 Answer Sorted by: Highest score (default) Date modified (newest first) Date created (oldest first) 118 When encrypting something with RSA, using PKCS#1 v1.5, the data that is to be encrypted is first padded, then the padded value is converted into an integer, and the RSA modular exponentiation (with the public exponent) is applied. Upon decryption, the modular exponentiation (with the private exponent) is applied, and then the padding is removed. The core of Bleichenbacher's attack relies on an oracle: the attack works if there is some system, somewhere, which can tell, given a sequence of bytes of the length of an encrypted message, whether decryption would yield something which has the proper padding format or not. An example would be a SSL/TLS server. In the initial handshake, at some point, the client is supposed to generate a random key (the "pre-master secret"), encrypt it with the server's public key, and send it. The server decrypts the value, obtains the pre-master secret, and then compute from that pre-master secret the keys used for symmetric encryption of the rest of the connection. Using the standard for guidance, the client sends a ClientKeyExchange (which contains the encrypted pre-master secret), then a ChangeCipherSpec, then Finished; this last message is encrypted with the derived symmetric key and its contents are verified by the server. If the client sends a random sequence of bytes of the right length to the server instead of a properly encrypted pre-master secret, then the server will, most of the time, respond with an error message telling "I tried to decrypt your ClientKeyExchange contents, but this failed, there was not a proper padding in it". However, by pure chance, it may happen that the random string, after applying the modular exponentiation, yields something which really looks like a pre-master secret with correct padding. In that case, the server will not complain about the ClientKeyExchange, but about the Finished message, which will be incorrectly encrypted. This is the information the attacker wants: whether the sequence of bytes he sent would, upon decryption, look properly padded or not. Let's see with a bit more technical details. In RSA, let ğ‘› ğ‘› be the public modulus. Let ğ‘€ ğ‘€ be a message to encrypt with ğ‘› ğ‘› (in the case of SSL, ğ‘€ ğ‘€ is the pre-master secret, of length 48 bytes). The PKCS#1 v1.5 padding, for encryption, consists in adding some bytes to the left, so that the total length after padding is equal to that of ğ‘› ğ‘› . For instance, if the server's public key is a 2048-bit RSA key, then ğ‘› ğ‘› has length 256 bytes, so the padded ğ‘€ ğ‘€ should also have length 256 bytes. A properly padded message ğ‘€ ğ‘€ has the following format: 0x00 0x02 [some non-zero bytes] 0x00 [here goes M] so the sequence of bytes will begin with a byte of value 0, then a byte of value 2, then some bytes which should have random values (but not zero), then a byte of value 0, then ğ‘€ ğ‘€ itself. The number of non-zero bytes is adjusted so that the total length is equal to the length of ğ‘› ğ‘› . Upon decryption, the server will look at the first two bytes, and require them to be equal to 0x00 and 0x02, in that order. Then it will scan for the next byte of value 0, thus skipping over all the random non-zero bytes. This way, the padding can be unambiguously removed. It follows that if the client sends a random string of bytes, then it has probability roughly between 2 âˆ’15 2 âˆ’ 15 and 2 âˆ’17 2 âˆ’ 17 to follow the PKCS#1 padding format (that's the probability that the first two bytes are 0x00 0x02, and that there is at least one byte of value 0 afterwards; exact probability depends on the length and value of ğ‘› ğ‘› ). The attack scenario is the following: There is a SSL server, which will send distinct error messages depending on whether a proper PKCS#1 padding was found or not. Alternatively, the two cases could be distinguished through some other information leak (e.g. the server takes longer to respond if the padding was correct). The attacker eavesdropped on a connection, and would like to decrypt it. He observed the ClientKeyExchange, so he saw an encrypted message ğ‘ ğ‘ . He knows that ğ‘= ğ‘š ğ‘’ (modğ‘›) ğ‘ = ğ‘š ğ‘’ ( mod ğ‘› ) where ğ‘’ ğ‘’ is the public exponent, and ğ‘š ğ‘š is the padded pre-master secret for that connection. He wants to recover ğ‘š ğ‘š , or at least the pre-master secret which is contained in ğ‘š ğ‘š , because that will allow him to compute the symmetric keys used for the connection. Then the attacker will initiate many connections to the server. For each connection, the attacker generates a value ğ‘  ğ‘  and sends, as ClientKeyExchange, a value ğ‘ â€² =ğ‘ ğ‘  ğ‘’ (modğ‘›) ğ‘ â€² = ğ‘ ğ‘  ğ‘’ ( mod ğ‘› ) . The server decrypts that, and obtains ğ‘š â€² =(ğ‘ ğ‘  ğ‘’ ) ğ‘‘ (modğ‘›) ğ‘š â€² = ( ğ‘ ğ‘  ğ‘’ ) ğ‘‘ ( mod ğ‘› ) ( ğ‘‘ ğ‘‘ is the private exponent), which is equal to ğ‘šğ‘ (modğ‘›) ğ‘š ğ‘  ( mod ğ‘› ) . Most of the time, this ğ‘šğ‘  ğ‘š ğ‘  value will not be properly padded (it will not begin with 0x00 0x02 or will not contain an extra 0x00). However, with a low but non-negligible probability (once every 30000 to 130000 attempts, roughly), luck will have it that the ğ‘šğ‘ (modğ‘›) ğ‘š ğ‘  ( mod ğ‘› ) value looks padded. If that is the case, then the server's behaviour will inform the attacker of that fact. The attacker then learns that, for this value ğ‘  ğ‘  (the attacker knows it, since he chose it), then ğ‘šğ‘ (modğ‘›) ğ‘š ğ‘  ( mod ğ‘› ) is in a specific range (the range of integers which begin with 0x00 0x02 when encoded in bytes using big-endian convention). The rest of the attack is trying again, with carefully chosen random values ğ‘  ğ‘  . Each time the server responds with "that was a proper PKCS#1 padding", this gives some information which helps the attacker narrow his guesses on ğ‘š ğ‘š . After a few million connections in all, the attacker learned enough to pinpoint the exact ğ‘š ğ‘š , yielding the pre-master secret. See the original article for details; once you know how the RSA padding works, the rest is just maths, which are not too hard. To prevent this attack, SSL servers do not inform the client about padding woes. If decryption fails because of a bad padding, then the server continues with a random pre-master secret (the true failure will then occur when processing the Finished message). One may note that the specific weakness of the PKCS#1 v1.5 padding (for encryption) is that it is not very redundant; the random bytes are, indeed, random, without any specifically enforced value. This is what allows a sequence of random bytes to be "properly padded" with a small but not negligible probability. Newer versions of PKCS#1 describe a new padding type, called OAEP, which uses hash function to add a lot of internal redundancy, which makes it extremely improbable that a random string matches the padding format. This prevents Bleichenbacher's attack. Unfortunately, SSL still uses PKCS#1 v1.5. Share Improve this answer Follow edited Oct 7, 2021 at 6:47 CommunityBot 1 answered Jan 3, 2014 at 15:53 Thomas Pornin 86.5k16 16 gold badges 239 239 silver badges 312 312 bronze badges 2 Even if the SSL server doesn't inform the client about padding error, the client can still tell that the padding wasn't right after the Finished message fails. â€“  Myath Jan 1, 2016 at 8:08 1 @Myath Also, you might be able to determine this fact via timing side-channels. :) â€“  Scott Arciszewski Jan 3, 2016 at 4:24 6 @Myath: ah no, that's the tricky point. If the server proceeds with a random key in case of bad padding, an inconsistent Finished does NOT reveal that the padding was bad -- maybe the padding was good, and the server merely used whatever pre-master secret it thus obtained (and is unknown to the attacker). â€“  Thomas Pornin Jan 3, 2016 at 12:52 1 @ThomasPornin Can you please tell me how we arrive at below conclusion: 2B <= ms mod n < 3B: where B = 2^8(kâˆ’2); I am not able to understand how value of B is defined and how we are able to say that the value will be in the range of 2B and 3B. â€“  Sam Jul 23, 2016 at 14:53 1 @sam A valid padding must be bigger than 00 02 00 00 ... And must be strictly smaller than 00 03 00 00 ... â€“  David å¤©å®‡ Wong May 15, 2018 at 15:45 Show 1 more comment Your Answer Sign up or log in Sign up using Google Sign up using Facebook Sign up using Email and Password Post as a guest Name Email Required, but never shown Post Your Answer By clicking â€œPost Your Answerâ€, you agree to our terms of service and acknowledge that you have read and understand our privacy policy and code of conduct. Not the answer you're looking for? Browse other questions tagged encryptionrsapublic-keychosen-ciphertext-attack or ask your own question. The Overflow Blog AI is only as good as the data: Q&A with Satish Jayanthi of Coalesce Tomasz Tunguz: From Java engineer to investor in eight unicorns Featured on Meta Practical effects of the October 2023 layoff Update: New Colors Launched Linked 55 What security authorities and standards reject ğ‘’=3 ğ‘’ = 3 in RSA, when, and with what rationale? 31 Using the same RSA keypair to sign and encrypt 17 Using ECB as RSA encryption mode when encrypted messages are unique? 9 How does PKCS 1.5 solve the insecureness of Textbook RSA? 7 Finding flaw in cryptographic protocol 5 What's the point of OAEP? 9 How to verify the integrity of RSA encrypted messages? 6 How can I securely encrypt the same message multiple times? 3 How can a system be non-deterministic? 14 Bleichenbacher 1998 "Million message attack" on RSA See more linked questions Related 3 Can you help with that definition for a CCA? 55 What security authorities and standards reject ğ‘’=3 ğ‘’ = 3 in RSA, when, and with what rationale? 5 Attack of an RSA signature scheme using PKCS#1 v1.5 encryption padding 6 RSA PKCS#1, v1.5 padding output 0 CCA on PKCS#5 using error feedback 2 Where does the range of possible values in Bleichenbacher's attack against PKCS #1 come from? 2 Can you please explain how Manger's attack against RSA OAEP works? Hot Network Questions I finished my basement during COVID without a permit - Now What Should I do? Is this brake mounted incorrectly? Big right brace in enumerate environment Asymptotic rate of decay of the integrals What does "make the Iacke go" mean? When should I switch antenna inputs on the Yaesu FT-897D? Could the Methuselah star be evidence that there was a universe before this one? Are login passwords saved on the machine or only a hash version of the password? A Trivial Pursuit #24 (Sports and Leisure 4/4): Color Pattern Convert 64-bit Gray code to integer Can human geniuses be cloned with modern technology? Bottom bracket differences How can I identify the input voltage for an unknown device? Were there any automatic timekeeping devices prior to the metronome used for setting and maintaining tempo (BPM) and pulse? What type of plane/model is this twin-engine plane in the photo? For loop through servers with custom ports (for i in "user1@server1 -p 12345" "user2@server2 -p 54321" ...; do) A German equivalent for "If it ain't broke, don't fix it." Is it mandatory to give four references in post-doctoral positions? What is a fungus formally? Real zeros of complex function Show that the sample Mean is not complete Conjugation by elements of subgroups Rashi with sources in context What are the ways that I can access the spell Find Familiar via magic items or feats? Question feed CRYPTOGRAPHY Tour Help Chat Contact Feedback COMPANY Stack Overflow Teams Advertising Collectives Talent About Press Legal Privacy Policy Terms of Service Cookie Settings Cookie Policy STACK EXCHANGE NETWORK Technology Culture & recreation Life & arts Science Professional Business API Data Blog Facebook Twitter LinkedIn Instagram Site design / logo Â© 2023 Stack Exchange Inc; user contributions licensed under CC BY-SA. rev 2023.11.3.372
